using Microsoft.CodeAnalysis;
using PrivateLike.Extensions;
using PrivateLike.Helpers;
using static Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle;

namespace PrivateLike.Models;

/// <summary>
/// A model describing the hierarchy info for a specific type.
/// </summary>
/// <param name="FullyQualifiedMetadataName">The fully qualified metadata name for the current type.</param>
/// <param name="Namespace">Gets the namespace for the current type.</param>
/// <param name="Hierarchy">Gets the sequence of type definitions containing the current type.</param>
internal sealed partial record HierarchyInfo(string FullyQualifiedMetadataName, string Namespace, EquatableArray<TypeInfo> Hierarchy)
{
    /// <summary>
    /// Creates a new <see cref="HierarchyInfo"/> instance from a given <see cref="INamedTypeSymbol"/>.
    /// </summary>
    /// <param name="typeSymbol">The input <see cref="INamedTypeSymbol"/> instance to gather info for.</param>
    /// <returns>A <see cref="HierarchyInfo"/> instance describing <paramref name="typeSymbol"/>.</returns>
    public static HierarchyInfo From(INamedTypeSymbol typeSymbol)
    {
        using ImmutableArrayBuilder<TypeInfo> hierarchy = new();

        for (INamedTypeSymbol? parent = typeSymbol;
             parent is not null;
             parent = parent.ContainingType)
        {
            hierarchy.Add(new TypeInfo(
                parent.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat),
                parent.TypeKind,
                parent.IsRecord));
        }

        return new(
            typeSymbol.GetFullyQualifiedMetadataName(),
            typeSymbol.ContainingNamespace.ToDisplayString(new(typeQualificationStyle: NameAndContainingTypesAndNamespaces)),
            hierarchy.ToImmutable());
    }

    /// <summary>
    /// Writes syntax for the current hierarchy into a target writer.
    /// </summary>
    /// <param name="writer">The target <see cref="IndentedTextWriter"/> instance to write text to.</param>
    public void WriteSyntax(IndentedTextWriter writer)
    {
        // Write the generated file header
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#pragma warning disable");
        writer.WriteLine();

        // Declare the namespace, if needed
        if (Namespace.Length > 0)
        {
            writer.WriteLine($"namespace {Namespace};");
            writer.WriteLine();
        }

        // Declare all types
        for (int i = Hierarchy.Length - 1; i >= 0; i--)
        {
            writer.WriteLine($$"""/// <inheritdoc cref="{{Hierarchy[i].QualifiedName}}"/>""");
            writer.WriteLineIf(i == 0, "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
            writer.WriteIf(i == 0, "internal ");
            writer.WriteLine($$"""partial {{Hierarchy[i].GetTypeKeyword()}} {{Hierarchy[i].QualifiedName}}""");
            writer.WriteLine($$"""{""");
            writer.IncreaseIndent();
        }

        // Close all scopes and reduce the indentation
        for (int i = 0; i < Hierarchy.Length; i++)
        {
            writer.DecreaseIndent();
            writer.WriteLine("}");
        }
    }
}